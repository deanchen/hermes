// Generated by CoffeeScript 1.3.1
(function() {
  var COMMIT, MAX_COMPLETE, MIN_COMPLETE, PIPELINE, SCORING, SCRIPT_HASH, STOP_WORDS, STORE_PREFIX_SCRIPT, args, client, clients, commitLine, completed, fill_pipeline, finished_processing, fs, hashKeyFields, hashSet, i, index, lazy, lockClient, lockWaitQueueSize, path, prefixClient, prefixScore, problemLines, processTitle, readLines, redis, sent, showStats, startTime, stats, storePrefixes, stream, termClient, totalWorkers, uprefixes, workerIndex;

  fs = require('fs');

  lazy = require('lazy');

  redis = require('redis');

  SCORING = {
    scale: 10,
    completeWordBonus: 1.4,
    dupPrefixPenalty: 0.5
  };

  PIPELINE = 10000;

  COMMIT = true;

  MIN_COMPLETE = 2;

  MAX_COMPLETE = 30;

  STOP_WORDS = fs.readFileSync('stop-words.txt', 'ascii').split('\n');

  SCRIPT_HASH = "";

  STORE_PREFIX_SCRIPT = fs.readFileSync('insertPrefix.lua', 'ascii');

  args = process.argv.splice(2);

  path = args[0];

  totalWorkers = args[1];

  workerIndex = args[2];

  uprefixes = {};

  problemLines = [];

  i = 0;

  clients = [];

  client = redis.createClient(6400, "127.0.0.1");

  client.select(0);

  clients.push(client);

  termClient = redis.createClient(6400, "127.0.0.1");

  termClient.select(1);

  clients.push(termClient);

  prefixClient = redis.createClient(6400, "127.0.0.1");

  prefixClient.select(2);

  clients.push(prefixClient);

  lockClient = redis.createClient(6400, "127.0.0.1");

  lockClient.select(3);

  clients.push(lockClient);

  /*
  client.send_command('script', ['load', STORE_PREFIX_SCRIPT, (err, res) ->
      if err then return console.log(err)
      SCRIPT_HASH = res
      readLines(stream, commitLine)
  )
  */


  index = 1;

  stats = {
    lines: 0,
    words: 0,
    prefixes: 0
  };

  startTime = new Date();

  sent = 0;

  completed = 0;

  finished_processing = false;

  stream = fs.createReadStream(path, {
    encoding: 'ascii'
  });

  stream.on('end', function() {
    return clients.forEach(function(client) {
      return client.quit();
    });
  });

  commitLine = function(line, i) {
    try {
      line = JSON.parse(line);
    } catch (e) {
      return console.log(e);
    }
    storePrefixes(line.id, processTitle(line.title));
    sent++;
    hashSet(termClient, line.id, JSON.stringify(line), function(err) {
      completed++;
      return fill_pipeline();
    });
    if (i % 100000 === 0) {
      return showStats(i);
    }
  };

  storePrefixes = function(id, prefixScores) {
    return client["eval"](STORE_PREFIX_SCRIPT, 2, JSON.stringify(prefixScores), id, function(err, ms) {
      completed++;
      fill_pipeline();
      if (err) {
        return console.log(err);
      }
    });
    /*
        Object.keys(prefixScores).forEach((prefix) ->
            return if prefix is ""
            score = prefixScores[prefix]
            sent++
            prefixClient.hincrby("prefixes", prefix, 1, (err, res) -> 
                unless res > 1023
                    sent++
                    client.zadd(prefix, score, id, (err) ->
                        completed++
                        fill_pipeline()
                    )
                else
                    uprefixes[prefix] = uprefixes[prefix] || 0
                    if score > uprefixes[prefix]
                        lockSet(prefix, id, (err) ->
                            client.zrange(prefix, 0, 0, 'withscores', (err, min) ->
                                setMinId = parseInt(min[0], 10)
                                setMinScore = parseInt(min[1], 10)
                                uprefixes[prefix] = setMinScore
                                if score > setMinScore
                                    console.log([setMinId, setMinScore], [id, score])
                                    client.zrem(prefix, setMinId)
                                    client.zadd(prefix, score, id)
                            )
                        )
            )
        )
    */

  };

  lockWaitQueueSize = 0;

  /*
  lockSet = (set, id, cb, repeat) ->
      lockClient.setnx(set, id, (err, res) -> 
          unless repeat then lockWaitQueueSize++
          console.log(set + ":" + id + ":" + res)
          if res is 1
              lockWaitQueueSize--
              fill_pipeline()
              cb(null)
          else
              process.nextTick(() -> lockSet(set, id, cb, true))
      )
  */


  processTitle = function(phrase) {
    var tokens;
    tokens = phrase.toLowerCase().replace(/[^a-z0-9 ]/ig, ' ').trim().split(' ').filter(function(word) {
      return !~STOP_WORDS.indexOf(word);
    }).map(function(word) {
      var lowerlimit, upperlimit, _i, _results;
      if (!COMMIT) {
        stats.words++;
      }
      if (word.length > MAX_COMPLETE) {
        upperlimit = MAX_COMPLETE - 1;
      } else {
        upperlimit = word.length - 1;
      }
      lowerlimit = MIN_COMPLETE - 1;
      if (lowerlimit < upperlimit) {
        return (function() {
          _results = [];
          for (var _i = lowerlimit; lowerlimit <= upperlimit ? _i <= upperlimit : _i >= upperlimit; lowerlimit <= upperlimit ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this).map(function(length) {
          return {
            "phrase": word.slice(0, length + 1 || 9e9),
            "score": prefixScore(length, upperlimit)
          };
        });
      } else {
        return [];
      }
    });
    if (tokens.length > 0) {
      return tokens.reduce(function(acc, prefixes) {
        prefixes.forEach(function(prefix) {
          if (acc[prefix.phrase]) {
            return acc[prefix.phrase] += Math.round(prefix.score * SCORING.dupPrefixPenalty);
          } else {
            return acc[prefix.phrase] = prefix.score;
          }
        });
        return acc;
      }, {});
    } else {
      return {};
    }
  };

  prefixScore = function(length, upperlimit) {
    length -= MIN_COMPLETE - 2;
    upperlimit -= MIN_COMPLETE - 2;
    if (length === upperlimit) {
      return SCORING.scale * SCORING.completeWordBonus;
    } else {
      return Math.round((length / upperlimit) * SCORING.scale);
    }
  };

  showStats = function(i) {
    stats["elapsed"] = ((new Date()).getTime() - startTime) / (60 * 1000);
    return client.info(function(err, info) {
      info = info.split('\r\n');
      return console.log({
        lines: i,
        elapsed: stats["elapsed"],
        memory: info[20],
        keys: info[43],
        sent: sent,
        completed: completed,
        estimateMem: ((20000000 / i) * (info[19].split(":")[1])) / 1073741824,
        remainingTime: Math.round((20000000 / i - 1) * stats["elapsed"])
      });
    });
  };

  fill_pipeline = function() {
    if ((sent - completed < PIPELINE) && (lockWaitQueueSize < 1)) {
      return stream.resume();
    }
  };

  readLines = function(input, cb) {
    var buffer, id;
    id = 1;
    buffer = '';
    input.on('data', function(data) {
      var line, _results;
      if ((sent - completed > PIPELINE) || (lockWaitQueueSize > 1)) {
        stream.pause();
      }
      buffer += data;
      index = buffer.indexOf('\n');
      _results = [];
      while (index > -1) {
        line = buffer.substring(0, index);
        buffer = buffer.substring(index + 1);
        if (((id % totalWorkers) === parseInt(workerIndex, 10)) || totalWorkers === 1) {
          cb(line, id++);
        } else {
          id++;
        }
        _results.push(index = buffer.indexOf('\n'));
      }
      return _results;
    });
    return input.on('end', function() {
      if (buffer.length > 0) {
        return cb(buffer, id++);
      }
    });
  };

  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };

  hashKeyFields = function(key) {
    var bucketSize;
    bucketSize = 1024;
    return {
      key: Math.round(key / bucketSize),
      field: key % bucketSize
    };
  };

  hashSet = function(client, key, value, cb) {
    var keyfields;
    keyfields = hashKeyFields(key);
    return client.hset(keyfields.key, keyfields.field, value, cb);
  };

  readLines(stream, commitLine);

}).call(this);
