// Generated by CoffeeScript 1.3.1
(function() {
  var CLIENTS, COMMIT, MAX_COMPLETE, MIN_COMPLETE, PIPELINE, STOP_WORDS, args, clients, commitLine, completed, fill_pipeline, finished_processing, fs, hashKeyFields, hashSet, i, index, lazy, path, prefix, prefixClient, readLines, redis, sent, startTime, stats, stream, termClient, totalWorkers, uprefixes, workerIndex;

  fs = require('fs');

  lazy = require('lazy');

  redis = require('redis');

  PIPELINE = 10000;

  COMMIT = true;

  MIN_COMPLETE = 2;

  MAX_COMPLETE = 30;

  STOP_WORDS = fs.readFileSync('stop-words.txt', 'ascii').split('\n');

  CLIENTS = 1;

  args = process.argv.splice(2);

  path = args[0];

  totalWorkers = args[1];

  workerIndex = args[2];

  uprefixes = {};

  clients = [];

  i = 0;

  while (i < CLIENTS) {
    console.log(i);
    clients.push(redis.createClient(6400, "127.0.0.1", {
      return_buffers: false
    }));
    i++;
  }

  termClient = redis.createClient(6400, "127.0.0.1");

  termClient.select(1);

  prefixClient = redis.createClient(6400, "127.0.0.1");

  prefixClient.select(2);

  index = 1;

  stats = {
    lines: 0,
    words: 0,
    prefixes: 0
  };

  startTime = new Date();

  sent = 0;

  completed = 0;

  finished_processing = false;

  stream = fs.createReadStream(path, {
    encoding: 'ascii'
  });

  commitLine = function(line, i) {
    var client, prefixes;
    if (COMMIT) {
      line = JSON.parse(line);
      client = clients[Math.round(i / totalWorkers) % CLIENTS];
      if (!line) {
        clients.forEach(function(client) {
          return client.quit();
        });
      }
      prefix(line.title).forEach(function(p) {
        if ((p === "") || uprefixes[p]) {
          return;
        }
        return prefixClient.hincrby("prefixes", p, 1, function(err, res) {
          if (!(res > 1023)) {
            uprefixes[p] = uprefixes[p] || 0;
            uprefixes[p]++;
            sent++;
            return clients[0].sadd(p, line.id, function(err) {
              completed++;
              return fill_pipeline();
            });
          } else {
            return uprefixes[p] = true;
          }
        });
      });
      sent++;
      hashSet(termClient, i, JSON.stringify(line), function(err) {
        completed++;
        return fill_pipeline();
      });
      if (i % 10000 === 0) {
        stats["elapsed"] = ((new Date()).getTime() - startTime) / 60000;
        return client.info(function(err, info) {
          info = info.split('\r\n');
          console.log({
            lines: i,
            elapsed: stats["elapsed"],
            memory: info[20],
            keys: info[43],
            sent: sent,
            completed: completed,
            estimateMem: ((20000000 / i) * (info[19].split(":")[1])) / 1073741824,
            remainingTime: (((20000000 / i) * stats["elapsed"]) - stats["elapsed"]) / 60
          });
          return console.log();
        });
      }
    } else {
      if (line) {
        stats.lines++;
        prefixes = prefix(line);
        prefixes.forEach(function(p) {
          if (p === "") {
            return;
          }
          if (!(uprefixes[p] > 1023)) {
            uprefixes[p] = uprefixes[p] || 0;
            uprefixes[p]++;
            return clients[0].sadd(p, i);
          } else {

          }
        });
        stats.prefixes += prefixes.length;
        clients[0].incr("c:");
        if (i % 10000 === 0) {
          stats["reallines"] = i;
          stats["words/line"] = stats.words / stats.lines;
          stats["prefix/word"] = stats.prefixes / stats.words;
          stats["prefix/line"] = stats.prefixes / stats.lines;
          stats["elapsed"] = ((new Date()).getTime() - startTime) / 60000;
          return clients[0].info(function(err, info) {
            info = info.split('\r\n');
            stats["memory"] = info[19].split(":")[1];
            stats["keys"] = info[43].split(",")[0].split("=")[1];
            stats["uprefix/line"] = stats.keys / i;
            stats["estimate"] = ((20000000 / i) * stats.memory) / 1073741824;
            return console.log(stats);
          });
        }
      }
    }
  };

  fill_pipeline = function() {
    if (sent - completed < PIPELINE) {
      return stream.resume();
    }
  };

  prefix = function(phrase) {
    var tokens;
    tokens = phrase.toLowerCase().replace('-', ' ').replace(/[^a-z0-9 ]/ig, ' ').trim().split(' ').filter(function(word) {
      return !~STOP_WORDS.indexOf(word);
    }).map(function(word) {
      var upperlimit, _i, _ref, _ref1, _results;
      if (!COMMIT) {
        stats.words++;
      }
      if (word.length > MAX_COMPLETE) {
        upperlimit = MAX_COMPLETE - 1;
      } else {
        upperlimit = word.length - 1;
      }
      return (function() {
        _results = [];
        for (var _i = _ref = MIN_COMPLETE - 1, _ref1 = upperlimit; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(length) {
        return word.slice(0, length + 1 || 9e9);
      });
    });
    if (tokens.length > 0) {
      return tokens.reduce(function(acc, prefixes) {
        return acc.concat(prefixes);
      }).unique();
    } else {
      return [];
    }
  };

  readLines = function(input, cb) {
    var buffer, id;
    id = 1;
    buffer = '';
    input.on('data', function(data) {
      var line, _results;
      if (sent - completed > PIPELINE) {
        stream.pause();
      }
      buffer += data;
      index = buffer.indexOf('\n');
      _results = [];
      while (index > -1) {
        line = buffer.substring(0, index);
        buffer = buffer.substring(index + 1);
        if (((id % totalWorkers) === parseInt(workerIndex, 10)) || totalWorkers === 1) {
          cb(line, id++);
        } else {
          id++;
        }
        _results.push(index = buffer.indexOf('\n'));
      }
      return _results;
    });
    return input.on('end', function() {
      if (buffer.length > 0) {
        return cb(buffer, id++);
      }
    });
  };

  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };

  readLines(stream, commitLine);

  hashKeyFields = function(key) {
    var bucketSize;
    bucketSize = 1024;
    return {
      key: Math.round(key / bucketSize),
      field: key % bucketSize
    };
  };

  hashSet = function(client, key, value, cb) {
    var keyfields;
    keyfields = hashKeyFields(key);
    return client.hset(keyfields.key, keyfields.field, value, cb);
  };

}).call(this);
